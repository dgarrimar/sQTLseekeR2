df.e <- fit$df.residual
df.i <- nlevels(groups.snp.f) - 1
e <- eigen(cov(R)*(n-1)/df.e, symmetric = T, only.values = T)$values
lambda <- abs(e[abs(e) > 1e-12])
item.acc <- 1e-14
pv.snp <- NEWpcqf(q = f.tilde, lambda = lambda, df.i = df.i, df.e = df.e, acc = item.acc)
while (length(pv.snp) > 1) {
item.acc <- item.acc * 10
pv.snp <- NEWpcqf(q = f.tilde, lambda = lambda, df.i = df.i, df.e = df.e, acc = item.acc)
}
if (pv.snp < item.acc) {
pv.snp <- item.acc
}
return(data.frame(pv.snp))
}
NEWcompute.empirical.pv <- function(genotype.gene, Y, best.snp, min.pv.obs, min.nb.ext.scores = 100, nb.perm.min = 100, nb.perm.max = 1000, comp.ld = TRUE, verbose = FALSE){
if(comp.ld) {
compute.ld <- function(df){
M <- as.matrix(df)
ns <- dim(M)[1]
if(ns == 1) {
return(NA)
}
R <- matrix(NA, ncol = ns, nrow = ns)
for (i in 1:(ns - 1)){
for (j in (1 + i):ns){
R[i, j] <- cor(M[i, ], M[j, ])^2
}
}
return(median(R, na.rm = T))
}
ld <- compute.ld(genotype.gene[, rownames(Y)])
}
variants.cis <- dim(genotype.gene)[1]
genotype.gene <- NEWLD.filter(genotype.gene = genotype.gene, com.samples = rownames(Y), Y = Y, th = 1, tol = 0)              #NEW, fix?
genotype.gene$LD <- NULL
if (verbose) {
message(sprintf("\tPASS not in perfect LD: %s", nrow(genotype.gene)))
message ("\tAdaptative permutation scheme")
}
t0 <- Sys.time()
store.perm = c()
i <- 1
ext <- 0
pv <- 1
while ( i <= nb.perm.min || (ext < min.nb.ext.scores && i <= nb.perm.max) ) {
# Note that i starts in 1. Thus "<=" instead of "<" in the while condition
if (verbose & i%%100 == 0) message (sprintf("\t\tpermutation %s",i))
min.pv.perm <- min(dplyr::do(dplyr::group_by(genotype.gene, snpId), NEWcompute.nominal.pv(., Y, permute = TRUE, seed = i))$pv.snp)
store.perm <- c(store.perm, min.pv.perm)
ext <- sum(store.perm <= min.pv.obs)
pv <- (ext + 1)/(i + 1)
i <- i + 1
}
fit <- fitdistrplus::mledist(store.perm, "beta")  # Estimate beta parameters on permutations
shape1 <- fit$estimate[1]
shape2 <- fit$estimate[2]
names(shape1) <- names(shape2) <- NULL
pv.beta <- pbeta(min.pv.obs, shape1 = shape1, shape2 = shape2)
t1 <- Sys.time()
t.run <- as.numeric(difftime(t1, t0, units = "mins"))
res.df <- data.frame(variants.cis = variants.cis, LD = ld, best.snp = best.snp, best.nominal.pv = min.pv.obs,
shape1 = shape1, shape2 = shape2, nb.perm = length(store.perm), pv.emp.perm = pv, pv.emp.beta = pv.beta,
runtime = t.run)
return(res.df)
}
NEWsqtl.seeker <- function (tre.df, genotype.f, gene.loc, genic.window = 5000,
min.nb.ext.scores = 1000, nb.perm.max = 1e+06, nb.perm.max.svQTL = 10000,
svQTL = FALSE, approx = TRUE, qform = TRUE, ld.filter = NULL,
min.nb.ind.geno = 10, verbose = FALSE, covariates = NULL)
{
. <- nb.groups <- snpId <- NULL
analyze.gene.f <- function(tre.gene) {
if (verbose)
message(tre.gene$geneId[1])
if (sum(duplicated(gene.loc$geneId)) > 1) {
stop(tre.gene$geneId[1], " Repeated gene in gene location file.")
}
gr.gene <- with(gene.loc[which(gene.loc$geneId == tre.gene$geneId[1]),
], GenomicRanges::GRanges(chr, IRanges::IRanges(start,
end)))
if (genic.window > 0) {
gr.gene <- GenomicRanges::resize(gr.gene, GenomicRanges::width(gr.gene) +
2 * genic.window, fix = "center")
}
if (length(gr.gene) > 0) {
if (!is.null(covariates)){
if (!all(covariates$sampleId %in% colnames(tre.gene))){
stop("All samples should have covariate information")                  ## NEW
}
cov.na <- apply(covariates, 1, function(x){any(is.na(x))})
covariates <- covariates[!cov.na, ]                                      ## NEW
if (sum(cov.na) > 0){
warning(sprintf("%s samples with NA values for at least one covariate have been removed.", sum(cov.na)))     ## NEW
}
}
tre.gene <- tre.gene[, !is.na(tre.gene[1, ])]
genotype.headers <- as.character(utils::read.table(genotype.f,
as.is = TRUE, nrows = 1))
if(!is.null(covariates)){
com.samples <- Reduce(intersect, list(colnames(tre.gene), genotype.headers, covariates$sampleId))   ## NEW
if (length(com.samples) == 0) {
stop("No common samples between genotype, covariate and transcript files.")
}
} else{
com.samples <- intersect(colnames(tre.gene), genotype.headers)
if (length(com.samples) == 0) {
stop("No common samples between genotype and transcript files.")
}
}
tre.gene <- tre.gene[, c("trId", "geneId", com.samples)] #NEW
# tre.dist <- sQTLseekeR2:::hellingerDist(tre.gene[, com.samples])           ## NEW
tre.tc <- t(sqrt(tre.gene[,com.samples]))
tre.tc <- scale(tre.tc, center = T, scale = F)
colnames(tre.tc) <- tre.gene$tr
# Here regress covariates and keep residual if applies
if(!is.null(covariates)){
fit <- lm(tre.tc ~ ., data = covariates)
tre.tc <- fit$residual
}
res.df <- data.frame()
if (GenomicRanges::width(gr.gene) > 20000 & is.null(ld.filter)) {
pos.breaks <- unique(round(seq(GenomicRanges::start(gr.gene),
GenomicRanges::end(gr.gene), length.out = floor(GenomicRanges::width(gr.gene)/10000) +
1)))
gr.gene.spl <- rep(gr.gene, length(pos.breaks) -
1)
GenomicRanges::start(gr.gene.spl) <- pos.breaks[-length(pos.breaks)]
pos.breaks[length(pos.breaks)] <- pos.breaks[length(pos.breaks)] +
1
GenomicRanges::end(gr.gene.spl) <- pos.breaks[-1] -
1
} else {
gr.gene.spl <- gr.gene
}
res.df <- lapply(1:length(gr.gene.spl), function(ii) {
res.range <- data.frame()
if (verbose) {
message("  Sub-range ", ii)
}
genotype.gene <- read.bedix(genotype.f, gr.gene.spl[ii])
if (verbose & is.null(genotype.gene)) {
message("\tNo SNPs in the genomic range.")
}
if (!is.null(genotype.gene)) {
snps.to.keep <- sQTLseekeR2:::check.genotype(genotype.gene[,
com.samples], tre.gene[, com.samples], min.nb.ind.geno = min.nb.ind.geno)
if (verbose) {
snps.to.keep.t <- table(snps.to.keep)
message("\t", paste(names(snps.to.keep.t),
snps.to.keep.t, sep = ": ", collapse = ", "))
}
if (any(snps.to.keep == "PASS")) {
genotype.gene <- genotype.gene[snps.to.keep ==
"PASS", ]
if (!is.null(ld.filter)) {
if (verbose) {
message("\tLD filtering")
}
genotype.gene <- NEWLD.filter(genotype.gene = genotype.gene,
com.samples = com.samples, Y = tre.tc,
th = ld.filter, svQTL = svQTL)              #NEW
}
res.range <- dplyr::do(dplyr::group_by(genotype.gene,
snpId), NEWcompFscore(., tre.tc,  # NEW
svQTL = svQTL, qform = qform))
}
}
return(res.range)
})
range.done <- which(unlist(lapply(res.df, nrow)) >
0)
if (length(range.done) > 0) {
res.df <- res.df[range.done]
res.df <- do.call(rbind, res.df)
if (!is.null(ld.filter)) {
ld <- res.df[, c("snpId", "LD")]
res.df$LD <- NULL
}
if (!qform) {
res.df <- dplyr::do(dplyr::group_by(res.df,
nb.groups), NEWcompPvalue(., tre.tc, approx = approx,
min.nb.ext.scores = min.nb.ext.scores, nb.perm.max = nb.perm.max))
}
if (svQTL) {
res.df <- dplyr::do(dplyr::group_by(res.df,
nb.groups), compPvalue(., tre.tc, svQTL = TRUE,
min.nb.ext.scores = min.nb.ext.scores, nb.perm.max = nb.perm.max.svQTL))
}
if (!is.null(ld.filter)) {
res.df <- merge(res.df, ld, by = "snpId")
}
res.df <- dplyr::arrange(res.df, pv)
return(data.frame(done = TRUE, res.df))
}
}
else {
if (verbose) {
warning("Issue with the gene location.")
}
}
return(data.frame(done = FALSE))
}
if (!approx & qform) {
warning("'qform' is ignored when 'approx' = FALSE. Type ?sqtl.seeker for more details.")
qform <- FALSE
}
ret.df <- lapply(unique(tre.df$geneId), function(gene.i) {
df <- tre.df[which(tre.df$geneId == gene.i), ]
data.frame(geneId = gene.i, analyze.gene.f(df))
})
done <- which(unlist(lapply(ret.df, ncol)) > 2)
if (length(done) > 0) {
ret.df <- ret.df[done]
ret.df <- do.call(rbind, ret.df)
ret.df$done <- NULL
return(ret.df)
}
else {
return(NULL)
}
}
NEWLD.filter <- function(genotype.gene, com.samples, Y, th = 1, tol = 0.05, svQTL = FALSE){
if (th > 1 | !is.numeric(th)){
stop ("Treshold for LD must be a numeric value <= 1.")
}
ids <- genotype.gene$snpId
g <- genotype.gene[, com.samples]
colnames(g) <- rownames(g) <- NULL
nG <- apply(g, 1, function(x)(length(table(x[x > -1])))) # Get nb of groups (2 or 3) for each SNP ID
M <- t(g)
M[M == -1] <- NA
res3 <- NEWcomputeLD(M = M[, nG == 3], ids = ids[nG == 3], Y = Y, th = th, tol = tol, svQTL = svQTL)
res2 <- NEWcomputeLD(M = M[, nG == 2], ids = ids[nG == 2], Y = Y, th = th, tol = tol, svQTL = svQTL)
if(is.null(res3) & !is.null(res2)){ # Some checks
res <- res2
}else if (!is.null(res3) & is.null(res2)){
res <- res3
}else{
res <- rbind(res3,res2)
}
if (is.null(res)){
genotype.gene$LD <- rep(NA, nrow(genotype.gene))
return(genotype.gene)
} else{
res <- as.data.frame(res)
colnames(res) <- "LD"
res$LD <- as.character(unlist(res$LD))
linked <- c(rownames(res), unlist(strsplit(res$LD, ", ", fixed = TRUE)))
indep_names <- ids[!ids%in%linked]
indep <- rep(NA, length(indep_names))
names(indep) <- indep_names
res <- rbind(res, data.frame(LD = indep))
rownames(genotype.gene) <- ids
genotype.gene <- merge(genotype.gene, res, by = "row.names")
genotype.gene <- with(genotype.gene, genotype.gene[order(chr, start), ])
genotype.gene$Row.names <- NULL
return(genotype.gene)
}
}
NEWcomputeLD <- function(M, ids, Y, th = 1, tol = 0.05, svQTL = FALSE){
M <- as.matrix(M)
if(ncol(M) > 1){
s <- ncol(M)
R <- cor(M, use = "pairwise.complete.obs")
R <- R^2
blocks <- lapply(as.data.frame(R),function(x) which(x >= th))
names(blocks) <- 1:s
# if (th < 1){
blocks <- NEWF.filter(blocks = blocks, Y = Y, M = M, tol = tol, svQTL = FALSE)
if(svQTL){
blocks <- NEWF.filter(blocks = blocks, Y = Y, M = M, tol = tol, svQTL = TRUE)
}
# }
store <- c()
bsc <- NEWprune_reorder(blocks, R)
blocks <- bsc[[1]]
bsizes <- bsc[[2]]
res <- list()
while(length(bsizes) > 0){
i <- names(bsizes[1])
group <- blocks[[i]]
res[[i]] <- group[group != as.numeric(i)]
store <- unique(c(store, group))
blocks[as.character(group)] <- NULL
blocks <- lapply(blocks, function(x) x[!x%in%store])
bsc <- NEWprune_reorder(blocks, R)
blocks <- bsc[[1]]
bsizes <- bsc[[2]]
}
if(length(unlist(res)) > 0){
res <- lapply(res, function(x) paste(ids[x], collapse=", "))
names(res) <- ids[as.numeric(names(res))]
res <- res[res != ""]
return(as.matrix(res))
}else{
return(NULL)
}
}else{
return(NULL)
}
}
NEWprune_reorder <- function (edges, R){
nedges <- unlist(lapply(edges, length))
nedges <- nedges[nedges > 1]
if(length(nedges) == 0){
return(list(edges,nedges))
}
edges <- edges[names(nedges)]
redges <- c()
for (e in names(edges)){
subs <- edges[[e]]
redges[e] <- mean(R[as.numeric(e), subs])
}
dd <- data.frame(redges,nedges)
ordered <- rownames(dd[with(dd, order(-redges, -nedges)), ])
nedges <- nedges[ordered]
return(list(edges, nedges))
}
NEWF.calc <- function(Y, snp, svQTL = FALSE){
if (any(is.na(snp))) {
non.na <- !is.na(snp)
snp <- snp[non.na]
Y <- Y[non.na, ]
}
snp.f <- factor(snp)
if(!svQTL){
dfnum <- nlevels(snp.f) - 1
dfden <- nrow(Y) - dfnum - 1
G <- tcrossprod(Y)
X <- stats::model.matrix(~., data = data.frame(genotype = snp.f), contrasts.arg = list("genotype" = "contr.sum"))
H <- tcrossprod(tcrossprod(X, solve(crossprod(X))), X)
numer <- crossprod(c(H), c(G))
trG <- sum(diag(G))
denom <- trG - numer
f.snp <- as.numeric((numer*dfden)/(denom*dfnum))
return(f.snp)
}else{
bd <- vegan::betadisper(dist(Y), snp.f, type = "centroid")
bd.perm <- sQTLseekeR2:::permutest.betadisper(bd, control = permute::how(nperm = 2))
return(bd.perm$F)
}
}
NEWF.filter <- function(blocks, Y, M, tol = 0.05, svQTL = FALSE){
if(svQTL){
tol <- 0.20 # Modify?
}
Fs <- apply(M, 2, function(x) NEWF.calc(Y = Y, snp = x, svQTL = svQTL))
names(Fs) <- 1:length(blocks)
d <- list()
for (e in names(blocks)){
subs <- blocks[[e]]
d[[e]] <- abs(Fs[as.character(subs)]-Fs[e])/Fs[e]
}
h <- list()
for (k in names(blocks)){
h[k] <- list(blocks[[k]] [ which(d[[k]] <= tol) ])
}
return(h)
}
NEWcompFscore <- function (geno.df, Y, svQTL = FALSE, qform = TRUE) {
if (nrow(geno.df) > 1) {
stop(geno.df$snpId[1], " SNP is duplicated in the genotype file.")
}
geno.snp <- as.numeric(geno.df[, rownames(Y)])
names(geno.snp) <- rownames(Y)
info.snp <- c()
tb.snp <- table(geno.snp)
for (gt in c("-1", "0", "1", "2")) {
info.snp[gt] <- ifelse(is.na(tb.snp[gt]), 0, tb.snp[gt])
}
if (any(geno.snp == -1)) {
non.na <- geno.snp > -1
geno.snp <- geno.snp[non.na]
Y <- Y[non.na, ]
}
info.snp <- paste(info.snp, collapse = ",")
groups.snp.f <- factor(as.numeric(geno.snp))
mdt <- NEWmd.trans(Y, groups.snp.f)
n <- nrow(Y)
nb.gp <- nlevels(groups.snp.f)
dfnum <- nb.gp - 1
dfden <- n - dfnum - 1
G <- tcrossprod(Y)
X <- stats::model.matrix(~., data = data.frame(genotype = groups.snp.f), contrasts.arg = list("genotype" = "contr.sum"))
H <- tcrossprod(tcrossprod(X, solve(crossprod(X))), X)
numer <- crossprod(c(H), c(G))
trG <- sum(diag(G))
denom <- trG - numer
f.tilde <- as.numeric(numer/denom)
if (qform) {
fit <- lm(Y ~ groups.snp.f)
R <- fit$residuals
e <- eigen(cov(R)*(n-1)/dfden, symmetric = T, only.values = T)$values
lambda <- abs(e[abs(e) > 1e-12])
item.acc <- 1e-14
pv.snp <- NEWpcqf(q = f.tilde, lambda = lambda, df.i = dfnum, df.e = dfden, acc = item.acc)
while (length(pv.snp) > 1) {
item.acc <- item.acc * 10
pv.snp <- NEWpcqf(q = f.tilde, lambda = lambda, df.i = dfnum, df.e = dfden, acc = item.acc)
}
if (pv.snp < item.acc) {
pv.snp <- item.acc
}
res.df <- data.frame(F = f.tilde*dfden/dfnum, nb.groups = nb.gp,
md = mdt$md, tr.first = mdt$tr.first, tr.second = mdt$tr.second,
info = info.snp, pv = pv.snp, stringsAsFactors = FALSE)
}
else {
res.df <- data.frame(F = f.tilde*dfden/dfnum, nb.groups = nb.gp,
md = mdt$md, tr.first = mdt$tr.first, tr.second = mdt$tr.second,
info = info.snp, stringsAsFactors = FALSE)
}
if (svQTL) {
res.df$F.svQTL <- NEWadonis.comp(Y, groups.snp.f,
permutations = 2, svQTL = TRUE)
}
if (any(colnames(geno.df) == "LD")) {
res.df$LD <- geno.df$LD
}
return(res.df)
}
NEWpcqf <- function (q, lambda, df.i, df.e, lim = 50000, acc = start.acc){
gamma <- c(lambda, -q * lambda)
nu <- c(rep(df.i, length(lambda)), rep(df.e, length(lambda)))
pv <- CompQuadForm::davies(0, lambda = gamma, h = nu, lim = lim, acc = acc)
if (pv$ifault != 0) {
return(pv)
}
if (pv$Qq < 0 || pv$Qq > 1) {
return(pv)
}
if (pv$ifault == 0) {
return(pv$Qq)
}
}
NEWadonis.comp <- function (Y, groups, permutations = 99, f.perms = FALSE, svQTL = FALSE,
approx = TRUE)
{
if (svQTL) {
bd <- vegan::betadisper(dist(Y), groups, type = "centroid")
bd.perm <- sQTLseekeR2:::permutest.betadisper(bd, control = permute::how(nperm = permutations))
if (f.perms) {
return(bd.perm$f.perms)
}
else {
return(bd.perm$F)
}
}
else {
if (approx) {
approx.dist <- function(Y, nb.mont, groups) {
nb.gp <- nlevels(groups)
n <- nrow(Y)
fit <- lm(Y ~ groups)
R <- fit$residuals
Df <- nb.gp - 1
Df.e <- fit$df.residual
e <- eigen(cov(R)*(n-1)/Df.e, symmetric = T, only.values = T)$values
eigenStats <- c(length(e), sum(e > 0), sum(e < 0))
if (eigenStats[3] > 0)
e <- abs(e)
randomChisqN <- matrix(stats::rchisq(nb.mont *
eigenStats[1], df = nb.gp - 1), nrow = eigenStats[1],
ncol = nb.mont)
randomChisqD <- matrix(stats::rchisq(nb.mont *
eigenStats[1], df = n - nb.gp), nrow = eigenStats[1],
ncol = nb.mont)
asymptNume <- e %*% randomChisqN
asymptDeno <- e %*% randomChisqD
asymptF <- asymptNume/asymptDeno * (n - nb.gp)/(nb.gp - 1)
return(asymptF)
}
return(approx.dist(Y, permutations, groups))
}
else {
res <- vegan::adonis(dist(Y) ~ groups, permutations = permutations)
return(as.numeric(res$f.perms[, 1]))
}
}
}
NEWmd.trans<-function (sr.o, groups.o) {
mTrans <- apply(sr.o, 2, function(sr.r) tapply(sr.r, groups.o, mean, na.rm = TRUE))
lr <- nrow(mTrans)
ind1 <- rep(1:(lr - 1), (lr - 1):1)
ind2 <- NULL
for (ii in 2:lr) {
ind2 <- c(ind2, ii:lr)
}
MDtrans <- apply(mTrans, 2, function(r) diff(rbind(r[ind1], r[ind2])))
if (!is.matrix(MDtrans)) {
MDtrans <- matrix(MDtrans, 1)
}
gpMD <- apply(MDtrans, 1, function(e) max(abs(e)))
gpMD.max <- which.max(gpMD)
tr.first <- names(which.max(abs(MDtrans[gpMD.max, ])))
tr.second <- names(which.max(-sign(MDtrans[gpMD.max, tr.first]) * MDtrans[gpMD.max, ]))
return(list(md = max(gpMD, na.rm = TRUE), tr.first = tr.first,
tr.second = tr.second))
}
devtools::install_github()
devtools::install_github(repo="")
source("../../vs3.1Diego_2wayCov/*")
source("../../vs3.1Diego_2wayCov/compFscore.R")
dir("../../vs3.1Diego_2wayCov/compFscore.R")
ls("../../vs3.1Diego_2wayCov/compFscore.R")
dir("../../vs3.1Diego_2wayCov)
)
dir("../../vs3.1Diego_2wayCov")
source(dir("../../vs3.1Diego_2wayCov"))
?source
dir("../../vs3.1Diego_2wayCov")
